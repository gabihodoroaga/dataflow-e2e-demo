package dataflow.e2e.demo

import com.google.api.services.bigquery.model.TableRow
import com.google.gson.Gson
import com.google.gson.JsonObject
import org.apache.beam.sdk.Pipeline
import org.apache.beam.sdk.io.gcp.bigquery.BigQueryIO
import org.apache.beam.sdk.io.gcp.bigquery.BigQueryIO.Write.CreateDisposition
import org.apache.beam.sdk.io.gcp.bigquery.BigQueryIO.Write.WriteDisposition
import org.apache.beam.sdk.io.gcp.pubsub.PubsubIO
import org.apache.beam.sdk.metrics.Metrics
import org.apache.beam.sdk.options.Description
import org.apache.beam.sdk.options.PipelineOptionsFactory
import org.apache.beam.sdk.options.StreamingOptions
import org.apache.beam.sdk.options.Validation
import org.apache.beam.sdk.transforms.DoFn
import org.apache.beam.sdk.transforms.ParDo
import org.apache.beam.sdk.values.PCollection
import org.apache.beam.sdk.values.TupleTag
import org.apache.beam.sdk.values.TupleTagList
import org.slf4j.LoggerFactory

interface DemoPipelineOptions : StreamingOptions {
    @get:Description("Pub/Sub subscription to read from.")
    @get:Validation.Required
    var inputSubscription: String

    @get:Description(
            "BigQuery table to write to, in the form 'project:dataset.table' or 'dataset.table'."
    )
    @get:Validation.Required
    var outputTable: String

    @get:Description(
            "BigQuery table to write to, in the form 'project:dataset.table' or 'dataset.table'."
    )
    @get:Validation.Required
    var output2Table: String

    @get:Description(
            "The build number generated by the deploy script to keep track of the version deployed in production"
    )
    var buildNumber: String
}

class DemoParseJsonMessage() : DoFn<String, TableRow>() {

    companion object {
        val GSON = Gson()
        val LOGGER = LoggerFactory.getLogger("dataflow.e2e.demo.DemoParseJsonMessage")

        val OUTPUT_TAG = object : TupleTag<TableRow>() {}
        val OUTPUT2_TAG = object : TupleTag<TableRow>() {}
    }

    val totalMessages = Metrics.counter(DemoParseJsonMessage::class.java, "totalMessages")
    val invalidMessages = Metrics.counter(DemoParseJsonMessage::class.java, "invalidMessages")

    @ProcessElement
    fun processElement(context: ProcessContext) {
        totalMessages.inc()
        val element = context.element()
        val msg: JsonObject
        val tableRow = TableRow()

        try {
            msg = GSON.fromJson(element, JsonObject::class.java)
        } catch (e: Exception) {
            LOGGER.error("error pasing message: ${element}, error: ${e}")
            invalidMessages.inc()
            return
        }

        if (msg.get("type") != null) {
            tableRow.set("type", msg.get("type").getAsString())
        }
        if (msg.get("data") != null) {
            tableRow.set("data", msg.get("data").getAsString())
        }

        when (tableRow.get("type").toString()) {
            "2" -> context.output(OUTPUT2_TAG, tableRow)
            else -> context.output(OUTPUT_TAG, tableRow)
        }
    }
}

fun main(args: Array<String>) {

    val options =
            PipelineOptionsFactory.fromArgs(*args)
                    .withValidation()
                    .`as`(DemoPipelineOptions::class.java)

    val tableSchemaJson = {}.javaClass.getResource("/table_schema.json").readText()
    val table2SchemaJson = {}.javaClass.getResource("/table2_schema.json").readText()

    val p = Pipeline.create(options)
    val rows =
            p.apply<PCollection<String>>(
                            "ReadFromPubsub",
                            PubsubIO.readStrings().fromSubscription(options.inputSubscription)
                    )
                    .apply(
                            "ParseJsonMessage",
                            ParDo.of(DemoParseJsonMessage())
                                    .withOutputTags(
                                            DemoParseJsonMessage.OUTPUT_TAG,
                                            TupleTagList.of(DemoParseJsonMessage.OUTPUT2_TAG)
                                    )
                    )
    rows.get(DemoParseJsonMessage.OUTPUT_TAG)
            .apply(
                    "WriteToBigQuery",
                    BigQueryIO.writeTableRows()
                            .to(options.outputTable)
                            .withJsonSchema(tableSchemaJson)
                            .withCreateDisposition(CreateDisposition.CREATE_IF_NEEDED)
                            .withWriteDisposition(WriteDisposition.WRITE_APPEND)
            )

    rows.get(DemoParseJsonMessage.OUTPUT2_TAG)
            .apply(
                    "WriteToBigQuery2",
                    BigQueryIO.writeTableRows()
                            .to(options.output2Table)
                            .withJsonSchema(table2SchemaJson)
                            .withCreateDisposition(CreateDisposition.CREATE_IF_NEEDED)
                            .withWriteDisposition(WriteDisposition.WRITE_APPEND)
            )

    p.run()
}
